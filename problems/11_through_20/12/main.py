'''
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1, 3
 6: 1, 2, 3, 6
10: 1, 2, 5, 10
15: 1, 3, 5, 15
21: 1, 3, 7, 21
28: 1, 2, 4, 7, 14, 28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
'''

# TODO: Use this algorithm once you understand it
# https://www.geeksforgeeks.org/first-triangular-number-whose-number-of-divisors-exceeds-n/

def printResult(number, triangle_number, divisors):
    number_suffix = ''
    if str(number)[-1] == '1':
        number_suffix = 'st'
    elif str(number)[-1] == '2':
        number_suffix = 'nd'
    elif str(number)[-1] == '3':
        number_suffix = 'rd'
    else:
        number_suffix = 'th'
    
    print('The ' + str(number) + number_suffix + ' triangle number (' + str(triangle_number) + ') is the first triangle number to have at least ' + str(len(divisors)) + ' divisors')
    print(divisors)

def getDivisors(triangle_number):
    if triangle_number == 1:
        return [1]

    if triangle_number == 3:
        return [1, 3]

    divisors = set([])
    number = triangle_number

    for divisor in range(1, number // 2):
        if number % divisor == 0:
            divisors.add(divisor)
            divisors.add(number // divisor)
    return sorted(list(divisors))

def bruteForce(required_number_of_divisors):
    triangle_number = 0
    number = 1
    while True:
        triangle_number += number

        divisors = getDivisors(triangle_number)
        if len(divisors) >= required_number_of_divisors:
            printResult(number, triangle_number, divisors)
            return

        number += 1

def prime_generator():
    yield 2
    n = 3
    while True:
        for x in range(2, n):
            if n % x == 0:
                break
        else:
            yield n
        n += 2

def populateCompositeDividers(number, prime_dividers, divisors = set([])):
    if number == 1:
        return

    divisors.add(number)

    for prime_divider in prime_dividers:
        if number % prime_divider == 0:
            populateCompositeDividers(number // prime_divider, prime_dividers, divisors)


def brains(required_number_of_divisors):
    triangle_number = 0
    number = 0
    prime_iterator = prime_generator()
    primes_to_check = [next(prime_iterator)]

    divisors = set([])
    prime_dividers = []
    while len(divisors) < required_number_of_divisors:
        divisors.clear()
        prime_dividers.clear()
        number += 1
        triangle_number += number

        # 1 and itself
        divisors.add(1)
        divisors.add(triangle_number)
        while primes_to_check[-1] < number:
            primes_to_check.append(next(prime_iterator))
        
        # All the primes
        prime_dividers = list([prime_to_check for prime_to_check in primes_to_check if triangle_number % prime_to_check == 0])
        for prime_divider in prime_dividers:
            divisors.add(prime_divider)
        
        # All composite numbers
        composite_dividers = set([])
        populateCompositeDividers(triangle_number, prime_dividers, composite_dividers)
        for composite_divider in composite_dividers:
            divisors.add(composite_divider)
    
    printResult(number, triangle_number, sorted(list(divisors)))

if __name__ == '__main__':
    required_number_of_divisors = 501

    import time
    # start_1 = time.perf_counter()
    # bruteForce(required_number_of_divisors)
    # end_1 = time.perf_counter()
    start_2 = time.perf_counter()
    brains(required_number_of_divisors)
    end_2 = time.perf_counter()

    # print(end_1 - start_1)
    print(end_2 - start_2)